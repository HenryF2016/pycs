#!/usr/bin/python
# -----------------------------------------------------------------------------
"""

Convert x.svd to x.py.

x.svd is a CMSIS System View Description file describing a device.
x.py is the same information presented as *.py code useable by pycs.

"""
# -----------------------------------------------------------------------------

import os
import sys

import lxml.etree as ET

# -----------------------------------------------------------------------------

svd2py_version = 1
infile = ''
outfile = ''

# -----------------------------------------------------------------------------
# utility functions

def description_cleanup(s):
  """cleanup a description string"""
  if s is None:
    return None
  # remove un-needed white space
  s = ' '.join([x.strip() for x in s.split()])
  # strip trailing period
  s = s.strip('.')
  return s

def rm_prefix(names, prefix_set):
  if prefix_set is None:
    return
  # find the longest matching prefix for all names
  n = 0
  for p in prefix_set:
    match = True
    for x in names:
      if not x[0].startswith(p):
        match = False
        break
    if match and len(p) > n:
      n = len(p)
  # remove the prefix
  if n:
    #print('removing prefix %s' % names[0][0][:n])
    for i in xrange(len(names)):
      names[i][0] = names[i][0][n:]

def rm_suffix(names, suffix_set):
  if suffix_set is None:
    return
  # find the longest matching suffix for all names
  n = 0
  for s in suffix_set:
    match = True
    for x in names:
      if not x[0].endswith(s):
        match = False
        break
    if match and len(s) > n:
      n = len(s)
  # remove the suffix
  if n:
    #print('removing suffix %s' % names[0][0][-n:])
    for i in xrange(len(names)):
      names[i][0] = names[i][0][:-n]

# -----------------------------------------------------------------------------

def lookup_derived_from(e, df_set):
  """return the end of the derivedFrom chain"""
  if e.derivedFrom is None:
    # this is the end of the chain
    return e
  for df in df_set:
    if e.derivedFrom == df.name:
      # recurse for multi-level deriveFrom
      return lookup_derived_from(df, df_set)

def set_derived_from(x, thing):
  """setup derived_from links between svd objects"""
  for e in x:
    if e.derivedFrom:
      e.derived_from = lookup_derived_from(e, x)
      #print('%s %s is derived from %s' % (thing, e.name, e.derived_from.name))

def consolidate_address_blocks(blocks, usage):
  """return the consolidated size (offset == 0) for a list of address blocks"""
  end = 0
  for b in blocks:
    if b.usage != usage:
      continue
    e = b.offset + b.size
    if e > end:
      end = e
  # return the size
  return end

class svd_object(object):

  def __init__(self):
    pass

  def attribute(self, x):
    name, value = x
    if value is not None:
      object.__setattr__(self, name, value)

  def __getattr__(self, name):
    return None

  def attribute_string(self, s, name):
    if self.__dict__.has_key(name):
      s.append("  '%s': '%s'," % (name, self.__dict__[name]))
    else:
      s.append("  # '%s': 'string'," % (name))

  def attribute_boolean(self, s, name):
    if self.__dict__.has_key(name):
      s.append("  '%s': %s," % (name, str(self.__dict__[name])))
    else:
      s.append("  # '%s': boolean," % (name))

  def attribute_integer(self, s, name):
    if self.__dict__.has_key(name):
      s.append("  '%s': %d," % (name, self.__dict__[name]))
    else:
      s.append("  # '%s': integer," % (name))

  def attribute_header(self, s, name):
    if self.__dict__.has_key(name):
      s.append('%s: %s' % (name, str(self.__dict__[name])))

# -----------------------------------------------------------------------------

# identifierType = string
# stringType = string
# xs:Name = string
# cpuNameType = string
# revisionType = string
# endianType = string
# xs:boolean = boolean
# scaledNonNegativeInteger = integer

def get_string(node, tag, default = None):
  """Get the text string for the tag from the node"""
  try:
    return node.find(tag).text
  except AttributeError:
    return default

def get_integer(node, tag, default = None):
  text_value = get_string(node, tag, default)
  try:
    if text_value != default:
      text_value = text_value.strip().lower()
      if text_value.startswith('0x'):
        return int(text_value[2:], 16)  # hexadecimal
      elif text_value.startswith('#'):
        # TODO(posborne): Deal with strange #1xx case better
        #
        # Freescale will sometimes provide values that look like this:
        #   #1xx
        # In this case, there are a number of values which all mean the
        # same thing as the field is a "don't care".  For now, we just
        # replace those bits with zeros.
        text_value = text_value.replace('x', '0')[1:]
        is_bin = all(x in '01' for x in text_value)
        return int(text_value, 2) if is_bin else int(text_value)  # binary
      elif text_value.startswith('true'):
        return 1
      elif text_value.startswith('false'):
        return 0
      else:
        return int(text_value)  # decimal
  except ValueError:
    return default
  return default

def get_boolean(node, tag, default = None):
  n = get_integer(node, tag, default)
  if n is None:
    return default
  return n != 0

# -----------------------------------------------------------------------------

def string_node(node, tag, default = None):
  return (tag, get_string(node, tag, default))

def boolean_node(node, tag, default = None):
  return (tag, get_boolean(node, tag, default))

def integer_node(node, tag, default = None):
  return (tag, get_integer(node, tag, default))

# -----------------------------------------------------------------------------
# handle the dimElementGroup

def x_dash_y_string(s, n):
  """parse a string of the form %d-%d"""
  x = s.split('-')
  if len(x) != 2:
    return None
  try:
    a = int(x[0], 10)
    b = int(x[1], 10)
  except:
    return None
  if (b - a + 1) != n:
    # wrong length
    return None
  return (a, b)

def build_indices(dim, dimIndex):
  """return a list of strings for the register name indices"""
  if dim is None:
    return None

  if dimIndex is None:
    # Assume a simple 0..n index
    return ['%d' % i for i in range(dim)]

  # handle a comma delimited list
  x = dimIndex.split(',')
  # make sure we have enough indices
  if len(x) == dim:
    return x

  # look for strings of the form "%d-%d"
  x = x_dash_y_string(dimIndex, dim)
  if x is not None:
    return ['%d' % i for i in range(x[0], x[1] + 1)]

  # something else....
  assert False, 'unhandled dim %d dimIndex %s' % (dim, dimIndex)

# -----------------------------------------------------------------------------

def bitrange_string(s):
  """parse a string of the form [%d:%d]"""
  s = s.lstrip('[')
  s = s.rstrip(']')
  x = s.split(':')
  try:
    msb = int(x[0], 10)
    lsb = int(x[1], 10)
  except:
    return None
  return (msb, lsb)

# -----------------------------------------------------------------------------

class svd_parser(object):

  @classmethod
  def read_file(cls, path):
    return cls(ET.parse(path))

  def __init__(self, tree):
    self.tree = tree
    self.root = self.tree.getroot()

  def get_field(self, node):
    f = svd_object()
    f.attribute(string_node(node, 'name'))
    f.attribute(string_node(node, 'description'))
    f.description = description_cleanup(f.description)
    f.attribute(string_node(node, 'access'))
    f.attribute(integer_node(node, 'bitOffset'))
    f.attribute(integer_node(node, 'bitWidth'))
    f.attribute(integer_node(node, 'lsb'))
    f.attribute(integer_node(node, 'msb'))
    f.attribute(string_node(node, 'bitRange'))
    f.derivedFrom = node.get('derivedFrom')
    return f

  def get_register(self, node):
    r = svd_object()
    r.attribute(integer_node(node, 'dim'))
    r.attribute(integer_node(node, 'dimIncrement'))
    r.attribute(string_node(node, 'dimIndex'))
    r.attribute(string_node(node, 'name'))
    r.attribute(string_node(node, 'displayName'))
    r.attribute(string_node(node, 'description'))
    r.description = description_cleanup(r.description)
    r.attribute(string_node(node, 'alternateGroup'))
    r.attribute(string_node(node, 'alternateRegister'))
    r.attribute(integer_node(node, 'addressOffset'))
    r.attribute(integer_node(node, 'size'))
    r.attribute(string_node(node, 'access'))
    r.attribute(string_node(node, 'protection'))
    r.attribute(integer_node(node, 'resetValue'))
    r.attribute(integer_node(node, 'resetMask'))
    r.attribute(string_node(node, 'dataType'))
    r.attribute(integer_node(node, 'resetMask'))
    r.attribute(string_node(node, 'modifiedWriteValues'))
    #<xs:element name="writeConstraint" type="writeConstraintType" minOccurs="0"/>
    r.attribute(string_node(node, 'readAction'))
    r.fields = [self.get_field(x) for x in node.findall('.//field')]
    r.derivedFrom = node.get('derivedFrom')

    # if a field is "derivedFrom" another field, add a derived_from reference
    set_derived_from(r.fields, 'field')
    return r

  def get_address_block(self, node):
    b = svd_object()
    b.attribute(integer_node(node, 'offset'))
    b.attribute(integer_node(node, 'size'))
    b.attribute(string_node(node, 'usage'))
    return b

  def get_interrupt(self, node):
    i = svd_object()
    i.attribute(string_node(node, 'name'))
    i.attribute(string_node(node, 'description'))
    i.description = description_cleanup(i.description)
    i.attribute(integer_node(node, 'value'))
    return i

  def get_peripheral(self, node):
    p = svd_object()
    p.attribute(string_node(node, 'name'))
    p.attribute(string_node(node, 'version'))
    p.attribute(string_node(node, 'description'))
    p.description = description_cleanup(p.description)
    p.attribute(string_node(node, 'alternatePeripheral'))
    p.attribute(string_node(node, 'groupName'))
    p.attribute(string_node(node, 'prependToName'))
    p.attribute(string_node(node, 'appendToName'))
    p.attribute(string_node(node, 'headerStructName'))
    p.attribute(string_node(node, 'disableCondition'))
    p.attribute(integer_node(node, 'baseAddress'))
    p.attribute(integer_node(node, 'size')) # default register size
    p.addressBlock = [self.get_address_block(x) for x in node.findall('./addressBlock')]
    p.interrupts = [self.get_interrupt(x) for x in node.findall('./interrupt')]
    p.registers = [self.get_register(x) for x in node.findall('.//register')]
    p.derivedFrom = node.get('derivedFrom')

    # if a register is "derivedFrom" another register, add a derived_from reference
    set_derived_from(p.registers, 'register')
    return p

  def get_device(self):
    """return the device described by the svd file"""
    # cpu
    node = self.root.find('./cpu')
    cpu = svd_object()
    cpu.attribute(string_node(node, 'name'))
    cpu.attribute(string_node(node, 'revision'))
    cpu.attribute(string_node(node, 'endian'))
    cpu.attribute(boolean_node(node, 'mpuPresent'))
    cpu.attribute(boolean_node(node, 'fpuPresent'))
    cpu.attribute(boolean_node(node, 'fpuDP'))
    cpu.attribute(boolean_node(node, 'icachePresent'))
    cpu.attribute(boolean_node(node, 'dcachePresent'))
    cpu.attribute(boolean_node(node, 'itcmPresent'))
    cpu.attribute(boolean_node(node, 'dtcmPresent'))
    cpu.attribute(boolean_node(node, 'vtorPresent'))
    cpu.attribute(integer_node(node, 'nvicPrioBits'))
    cpu.attribute(boolean_node(node, 'vendorSystickConfig'))
    cpu.attribute(integer_node(node, 'deviceNumInterrupts'))
    cpu.attribute(integer_node(node, 'sauNumRegions'))
    #<xs:element name="sauRegionsConfig" minOccurs="0">

    # device
    node = self.root
    device = svd_object()
    device.attribute(string_node(node, 'vendor'))
    device.attribute(string_node(node, 'vendorID'))
    device.attribute(string_node(node, 'name'))
    device.attribute(string_node(node, 'series'))
    device.attribute(string_node(node, 'version'))
    device.attribute(string_node(node, 'description'))
    device.attribute(string_node(node, 'licenseText'))
    device.cpu = cpu
    device.attribute(string_node(node, 'headerSystemFilename'))
    device.attribute(string_node(node, 'headerDefinitionsPrefix'))
    device.attribute(integer_node(node, 'addressUnitBits'))
    device.attribute(integer_node(node, 'width'))
    device.peripherals = [self.get_peripheral(x) for x in self.root.findall('.//peripheral')]

    # if a peripheral is "derivedFrom" another peripheral, add a derived_from reference
    set_derived_from(device.peripherals, 'peripheral')
    return device


# -----------------------------------------------------------------------------

class py_output(object):

  def __init__(self, fname, device):
    self.fname = fname
    self.device = device

  def emit_header(self, f):
    """emit the informational file header"""
    s = []
    s.append('"""')
    s.append('generated by svd2py version %d' % svd2py_version)
    self.device.attribute_header(s, 'vendor')
    self.device.attribute_header(s, 'name')
    self.device.attribute_header(s, 'description')
    self.device.attribute_header(s, 'series')
    self.device.attribute_header(s, 'version')
    s.append('"""')
    s.append('from regs import fld, fld_set, reg32, reg16, reg8, regset, memio')
    f.write('%s\n' % '\n'.join(s))

  def emit_fields(self, f):
    """emit the field sets"""
    s = []

    for p in self.device.peripherals:
      if not p.registers:
        # no registers therefore no fields
        continue

      for r in p.registers:
        if not r.fields:
          continue

        # build a list of fields [name, msb, lsb]
        fldset = []
        for field in r.fields:
          if field.bitWidth is not None:
            lsb = field.bitOffset
            msb = lsb + field.bitWidth - 1
          elif field.msb is not None:
            lsb = field.lsb
            msb = field.msb
          elif field.bitRange:
            (msb, lsb) = bitrange_string(field.bitRange)
          else:
            assert False, 'need to work out bit field for %s' % field.name
          fldset.append([field.name, msb, lsb])

        # output
        s.append('f = []')
        for (name, msb, lsb) in fldset:
          s.append("f.append(fld('%s', %s, %d))" % (name, msb, lsb))
        s.append("%s_%s_fields = fldset('%s', f)" % (p.name, r.name, r.description))
        s.append('')

    f.write('%s\n' % '\n'.join(s))

  def emit_registers(self, f):
    s = []
    for p in self.device.peripherals:
      if p.derivedFrom and len(p.registers) == 0:
        continue
      if p.derivedFrom is None and len(p.registers) == 0:
        print('%s (info): peripheral %s is not derived and has no registers' % (self.device.name, p.name))
        continue
      if p.derivedFrom and len(p.registers):
        print('%s (info): peripheral %s is derived and has registers' % (self.device.name, p.name))
        continue

      # build a list of registers [name, size, offset, fields, description]
      regset = []
      for r in p.registers:
        r_from = (r.derived_from, r)[r.derived_from is None]

        # work out the fields name
        # TODO take care of dimensioned register names
        fields = ('%s_%s_fields' % (p.name, r.name), 'None')[r_from.fields is None]

        # get the deault size from the peripheral if the register has no size
        size = (r_from.size, p.size)[r_from.size is None]

        if r.dim is None:
          regset.append([r.name, size, r.addressOffset, fields, r.description])
        else:
          indices = build_indices(r.dim, r.dimIndex)
          for i in range(r.dim):
            # standard practice puts a "%s" in the name string. Is this always true?
            assert r.name.__contains__('%s'), 'indexed register name %s has no %%s' % r.name
            ofs = r.addressOffset + (i * r.dimIncrement)
            name = r.name % indices[i]
            regset.append([name, size, ofs, fields, r.description])

      # remove prefix/suffix
      rm_prefix(regset, ('NVIC_',))
      rm_suffix(regset, None)

      # sort by offset
      regset.sort(key = lambda x: x[2])

      # output
      s.append('r = []')
      for (name, size, ofs, fields, description) in regset:
        comment = (' # %s' % description, '')[description is None]
        s.append("r.append(reg%d('%s', 0x%x, %s))%s" % (size, name, ofs, fields, comment))
      s.append("%s_regs = regset('%s', r)" % (p.name, p.description))
      s.append('')
    f.write('%s\n' % '\n'.join(s))

  def emit_memmap(self, f):
    """emit the memory map"""
    s = []
    s.append('memmap = {')
    for p in self.device.peripherals:
      p_from = (p.derived_from, p)[p.derived_from is None]

      # check that the peripheral has an address block
      blocks = p_from.addressBlock
      if blocks is None:
        print("%s (error): peripheral %s has no 'registers' address block" % (self.device.name, p.name))
        continue

      size = consolidate_address_blocks(blocks, 'registers')
      comment = (' # %s' % p_from.description, '')[p_from.description is None]
      regs = ('%s_regs' % p_from.name, "'%s'" % p_from.description)[len(p_from.registers) == 0]
      s.append("  '%s': (0x%08x, 0x%x, %s),%s" % (p.name, p.baseAddress, size, regs, comment))

    s.append('}')
    s.append('')
    f.write('%s\n' % '\n'.join(s))

  def emit_vtable(self, f):
    """emit the vector table"""
    # get the interrupts - there may be duplicates so we de-dup them in a dictionary
    irqs = {}
    for p in self.device.peripherals:
      for i in p.interrupts:
        if irqs.has_key(i.value):
          # should be the same name
          assert irqs[i.value][0] == i.name
        else:
          irqs[i.value] = [i.name, i.description]

    # convert to a sorted list of [name, interrupt, description]
    irqset = [[irqs[i][0], i, irqs[i][1]] for i in sorted(irqs.keys())]

    # remove prefix/suffix
    rm_prefix(irqset, ('INT_',))
    rm_suffix(irqset, ('_IRQ',))

    # output
    s = []
    s.append('vtable = {')
    for (name, i, description) in irqset:
      comment = (' # %s' % description, '')[description is None]
      s.append("  %d: '%s',%s" % (i, name, comment))
    s.append('}')
    s.append('')
    f.write('%s\n' % '\n'.join(s))

  def emit_cpu(self, f):
    """emit the cpu parameters"""
    cpu = self.device.cpu
    s = []
    s.append('cpu = {')
    cpu.attribute_string(s, 'name')
    cpu.attribute_string(s, 'revision')
    cpu.attribute_string(s, 'endian')
    cpu.attribute_boolean(s, 'mpuPresent')
    cpu.attribute_boolean(s, 'fpuPresent')
    cpu.attribute_boolean(s, 'fpuDP')
    cpu.attribute_boolean(s, 'icachePresent')
    cpu.attribute_boolean(s, 'dcachePresent')
    cpu.attribute_boolean(s, 'itcmPresent')
    cpu.attribute_boolean(s, 'dtcmPresent')
    cpu.attribute_boolean(s, 'vtorPresent')
    cpu.attribute_integer(s, 'nvicPrioBits')
    cpu.attribute_boolean(s, 'vendorSystickConfig')
    cpu.attribute_integer(s, 'deviceNumInterrupts')
    s.append('}')
    s.append('')
    f.write('%s\n' % '\n'.join(s))

  def emit_device(self, f):
    """emit overall device information"""
    s = []
    s.append('device = {')
    self.device.attribute_string(s, 'name')
    self.device.attribute_string(s, 'vendor')
    self.device.attribute_string(s, 'series')
    self.device.attribute_string(s, 'version')
    s.append("  'vtable': vtable,")
    s.append("  'memmap': memmap,")
    s.append("  'cpu': cpu,")
    s.append('}')
    s.append('')
    f.write('%s\n' % '\n'.join(s))

  def emit(self):
    f = open(self.fname, 'w')
    self.emit_header(f)
    self.emit_fields(f)
    self.emit_registers(f)
    self.emit_vtable(f)
    self.emit_memmap(f)
    self.emit_cpu(f)
    self.emit_device(f)
    f.close()

# -----------------------------------------------------------------------------

def pr_err(*args):
  sys.stderr.write(' '.join(map(str,args)) + '\n')
  sys.stderr.flush()

def pr_usage(argv):
  pr_err('Usage: %s <input_file> <output_file>' % argv[0])

def error(msg, usage = False):
  pr_err(msg)
  if usage:
    pr_usage(sys.argv)
  sys.exit(1)

def Process_Options(argv):
  """process command line options"""
  global infile, outfile

  # get the input file
  if len(sys.argv) < 2:
    error('must specify input file', True)
  infile = sys.argv[1]
  if not os.path.exists(infile):
    error('%s: input file does not exist' % infile, True)

  # get the output file
  if len(sys.argv) < 3:
    error('must specify output file', True)
  outfile = sys.argv[2]

# -----------------------------------------------------------------------------

def main():
  Process_Options(sys.argv)
  parser = svd_parser.read_file(infile)
  device = parser.get_device()
  py_output(outfile, device).emit()

main()

# -----------------------------------------------------------------------------
