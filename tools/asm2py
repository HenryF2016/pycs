#!/usr/bin/python
# -----------------------------------------------------------------------------
"""

assembly to python

Generate a tuple of 32-bit opcode values for an assembly language routine.

32-bit buffer transfers to target memory are generally the fastest so
we generate the output in this form.

"""
# -----------------------------------------------------------------------------

import sys
import os
import subprocess

# -----------------------------------------------------------------------------
# cross compilation tools

tool_path = '/opt/gcc-arm-none-eabi-5_4-2016q2/bin/'
cpp_tool = tool_path + 'arm-none-eabi-cpp'
as_tool = tool_path + 'arm-none-eabi-as'
gcc_tool = tool_path + 'arm-none-eabi-gcc'
objcopy_tool = tool_path + 'arm-none-eabi-objcopy'

# -----------------------------------------------------------------------------

ram_start = 0x20000000

# -----------------------------------------------------------------------------

def process(asm_fname):

  basename = asm_fname.split('.')[0]
  obj_fname = basename + '.o'
  elf_fname = basename + '.elf'
  bin_fname = basename + '.bin'

  # assemble the *.S file
  # cpp $< | as -o $@
  cmd = '%s %s | %s -o %s' % (cpp_tool, asm_fname, as_tool, obj_fname)
  subprocess.call(cmd, shell = True)

  # link the object to resolve branch labels
  # gcc $(FLAGS) $< -o $@
  flags = '-static -nostdinc -nostartfiles -nodefaultlibs -nostdlib -ffreestanding '
  flags += '-Xlinker --section-start=.text=0x%08x ' % ram_start
  flags += '-Xlinker --entry=0x%08x ' % ram_start
  cmd = '%s %s %s -o %s' % (gcc_tool, flags, obj_fname, elf_fname)
  subprocess.call(cmd, shell = True)

  # dump the text segment binary
  # objcopy -j .text $< -O binary $@
  cmd = '%s -j .text %s -O binary %s' % (objcopy_tool, elf_fname, bin_fname)
  subprocess.call(cmd, shell = True)

  # get the binary data
  f = file(bin_fname, 'rb')
  x = f.read()
  f.close()

  # file cleanup
  os.remove(obj_fname)
  os.remove(elf_fname)
  os.remove(bin_fname)

  # convert to an 8-bit buffer
  buf8 = [ord(c) for c in x]

  # check length
  n = len(buf8)
  if n == 0:
    # no data
    return

  # pad with zeroes to 32 bits
  if n & 3:
    buf8.extend((0,) * (4 - (n & 3)))

  # convert to 32-bit little endian
  buf32 = [(buf8[i] << 0) | (buf8[i + 1] << 8) | (buf8[i + 2] << 16) | (buf8[i + 3] << 24) for i in xrange(0, len(buf8), 4)]

  # dump the binary to stdout as a python tuple
  print('%s = (' % basename)
  print '\n'.join(['  0x%08x,' % x for x in buf32])
  print(')')

# -----------------------------------------------------------------------------

def print_usage():
  sys.stderr.write('usage: %s <file>\n' % sys.argv[0])

def print_error(msg):
  sys.stderr.write('error: %s\n' % msg)

def main():

  if len(sys.argv) != 2:
    print_usage()
    sys.exit(1)

  asm_fname = sys.argv[1]

  # check the file
  if not os.path.isfile(asm_fname):
    print_error('file %s not found' % asm_fname)
    sys.exit(1)

  # check the tools
  if not os.path.isfile(gcc_tool):
    print_error('%s not found, fix the tool path' % gcc_tool)
    sys.exit(1)

  process(asm_fname)

main()

# -----------------------------------------------------------------------------


